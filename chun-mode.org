#+title: Chun-mode
#+STARTUP: overview indent
#+OPTIONS: num:nil

Some emacs configs I used without any personal information.

Babel mode is a good place to take notes.

* Utilities
** OS related
*** get OS type

#+BEGIN_SRC emacs-lisp
(defun chun/is-on-mac ()
  (string-equal system-type "darwin"))
(defun chun/is-on-linux ()
  (string-equal system-type "gnu/linux"))
(defun chun/is-on-windows ()
  (string-equal system-type "windows-nt"))
#+END_SRC

#+RESULTS:
: chun/is-on-windows


** string related
** time related
*** insert today's date

#+BEGIN_SRC emacs-lisp
 (defun chun/insert-current-date (&optional omit-day-of-week-p)
    "Insert today's date using the current locale.
  With a prefix argument, the date is inserted without the day of
  the week."
    (interactive "P*")
    (insert (calendar-date-string (calendar-current-date) nil
				  omit-day-of-week-p)))
#+END_SRC

#+RESULTS:
: chun/insert-current-date

** edit related
*** org-mode inline code with ~~

#+BEGIN_SRC emacs-lisp
(defun chun/--set-inline-code-wrapper ()
  (let* (start
         end
         (space "[?\s?\n?,]"))
    (when (re-search-forward space nil t)
      (setq end (point))
      (backward-char 1)
      (when (re-search-backward space nil t)
        (setq start (point))
        (goto-char start)
        (forward-char 1)
        (insert "~")
        (goto-char end)
        (insert "~")))))

(defun chun/wrap-inline-code ()
  (interactive)
  (chun/--set-inline-code-wrapper))
#+END_SRC

#+RESULTS:
: chun/wrap-inline-code


#+BEGIN_SRC emacs-lisp
(after! org-mode
  (add-hook 'org-mode
            (lambda () (local-set-key (kbd "C-x C-w") #'chun/wrap-inline-code))))
#+END_SRC

#+RESULTS:

** IO related
*** alias some crux helper functions
**** Remove the current file and buffer
#+BEGIN_SRC emacs-lisp
(defalias 'chun/remove-file 'crux-delete-buffer-and-file)
#+END_SRC

#+RESULTS:
: chun/remove-file

**** Find recently visited file

#+BEGIN_SRC emacs-lisp
(defalias 'chun/find-recent-file 'crux-recentf-find-file)
#+END_SRC

#+RESULTS:
: chun/find-recent-file

*** Get current file name

#+BEGIN_SRC emacs-lisp
(defun chun/get-file-name ()
  "Get the filename without directory to clipboard."
  (interactive)
  (kill-new
   (file-name-nondirectory (buffer-file-name))))
#+END_SRC

#+RESULTS:
: chun/get-file-name

*** Get the directory of this file

#+BEGIN_SRC emacs-lisp
(defun --chun-cur-dir ()
  (if load-file-name
      (file-name-directory load-file-name)
    default-directory))
#+END_SRC

#+RESULTS:
: /Users/yanchunwei/emacs-dev/




* Configs and commands
** Treat ~_~ as part of word

#+BEGIN_SRC emacs-lisp
(defun chun/--treat-_-as-word ()
  "Treat '_' as part of word."
  (modify-syntax-entry ?_ "w"))

(add-hook! markdown-mode-hook 'chun/--treat-_-as-word)
(add-hook! graphviz-mode-hook 'chun/--treat-_-as-word)
(add-hook! emacs-lisp-mode-hook 'chun/--treat-_-as-word)
(add-hook! c++-mode-hook 'chun/--treat-_-as-word)
#+END_SRC

#+RESULTS:

** STRT global mark
General idea:

1. hold a global dictionary mapping from annotation to file&lineno
2. user's interface
   - [ ] add a record to the dictionary
   - [ ] clean all the records
   - [ ] remove a record
   - [ ] jump to the line of a record
   - [X] eager update, might too hard in the begining, if new lines are inserted before, update the related lineno.

The dependencies of knowledge:

- helm for providing an interface for query the record
- associate list?


Define a structure for point


#+BEGIN_SRC emacs-lisp
(require 'cl-lib)

(cl-defstruct chun-point-mark
  ;; the filepath
  filename
  ;; point in a file
  point
  )
#+END_SRC

#+RESULTS:
: chun-point-mark

Define a global map to remember the ~chun-point-mark~ records.


#+BEGIN_SRC emacs-lisp
(require 'ht)

(setq chun-point-mark-dic
      (ht-create))
#+END_SRC

#+RESULTS:
: #s(hash-table size 65 test equal rehash-size 1.5 rehash-threshold 0.8125 data ())

Define some helper functions to get necesssary information for the point.


#+BEGIN_SRC emacs-lisp
(defun --chun-point-mark-get-point-for-current-position ()
  "Get a point-mark instance for the current position."
  (let* ((file-path (file-truename buffer-file-name))
         (new-mark (make-marker))
         (cur-point (point))
         )
    (set-marker new-mark (point))
    (make-chun-point-mark :filename file-path :point new-mark)))
#+END_SRC

#+RESULTS:
: --chun-point-mark-get-point-for-current-position


#+BEGIN_SRC emacs-lisp
(defun --chun-point-mark-goto-position (pos)
  "Go to the position a point-mark points to.
pos: chun-point-mark
"
  (let* ((file-path (chun-point-mark-filename pos))
         (the-point (chun-point-mark-point pos))
         )
    (switch-to-buffer
     (find-file-noselect file-path))
    (goto-char the-point)))
#+END_SRC

#+RESULTS:
: --chun-point-mark-goto-position


Define serveral functions to manipulating the records.

#+BEGIN_SRC emacs-lisp
(defun --chun-point-mark-get-record (key)
  "Get a point-mark record."
  (ht-get chun-point-mark-dic key)
  )
#+END_SRC

#+RESULTS:
: --chun-point-mark-get-record

#+BEGIN_SRC emacs-lisp
(defun --chun-point-mark-set-record (key instance)
  "Set or add a record in point-mark dic.
key: string
instance: chun-point-mark
"
  (ht-set! chun-point-mark-dic key instance)
  )
#+END_SRC

#+RESULTS:
: --chun-point-mark-set-record



Define some user interfaces including:

- add-point, add or update a point to the global record
  - Use a interactive to set a name to this point
- delete-point, delete a point
  - Use a helm to choose an existing record to remove
- goto-point
  - Use a helm to select an existing record to goto


#+BEGIN_SRC emacs-lisp
(defun chun-point-mark-add-current(key)
  (interactive "M")
  (let* ((cur-point
          (--chun-point-mark-get-point-for-current-position))
         )
    (--chun-point-mark-set-record key cur-point)))
#+END_SRC

#+RESULTS:
: chun-point-mark-add-current


#+BEGIN_SRC emacs-lisp
(defun chun-point-mark-goto (key)
  "Goto a point annotated by key."
  (interactive (list (helm :sources (helm-build-sync-source "keys"
                                      :candidates (ht-keys chun-point-mark-dic)
                                      :fuzzy-match t)
                           :buffer "*chun-point-mark*")))

  (let* ((the-point (--chun-point-mark-get-record key)))
    (if the-point
        (--chun-point-mark-goto-position the-point))))
#+END_SRC

#+RESULTS:
: chun-point-mark-goto


Add marks


#+BEGIN_SRC emacs-lisp
(map! :leader
      :desc "Add point mark" "pa" #'chun-point-mark-add-current)
(map! :leader
      :desc "Goto point mark" "pg" #'chun-point-mark-goto)
#+END_SRC

#+RESULTS:
: chun-point-mark-goto





** TODO Bilingual viewer
*** Utilities to get content within an org-mode heading
The English content starts with ~En~ heading, and the Chinese content starts with ~Ch~ heading.

#+RESULTS:
: chun-bili-get-content-at-this-point

**** Example heading
:PROPERTIES:
ANKI_NOTE_TYPE: the note type
ANKI_DOCK: the dock
:END:
***** En
a brief summary
hello world
***** Ch
简要的总结

你好世界

*** Create a bilingual data structure
A list with each item is a pair of English and Chinese sentences.

*** Bilingual dump to org-mode content

*** Create or open a new org-mode file for anki

*** Each anki contains a url point to google translate
This is necessary for pronunciation

** Declare a custom variable for environment name

#+BEGIN_SRC emacs-lisp
(defcustom chun-mode/pc-name ""
  "The PC name used for config customization which are different on different PCs."
  :type 'string
  :group 'chun)
#+END_SRC

#+RESULTS:
: chun-mode/pc-name


* Org-mode related
** org babel

#+BEGIN_SRC emacs-lisp
(defun org-insert-src-block (src-code-type)
  "Insert a `SRC-CODE-TYPE' type source code block in org-mode."
  (interactive (let* ((src-code-types '("emacs-lisp" "python" "C" "sh" "java" "js" "clojure" "C++"
                                       "css" "calc" "asymptote" "dot" "gnuplot" "ledger" "lilypond"
                                       "mscgen" "octave" "oz" "plantuml" "R" "sass" "screen" "sql"
                                       "awk" "ditaa" "haskell" "latex" "lisp" "matlab" "ocaml" "org"
                                       "perl" "ruby" "scheme" "sqlite"
                                       "cpp" "cmake" "swift" "cuda" "llvm" "td" "ptx" "yaml"
                                       )))
                 (list (ido-completing-read "Source code type: " src-code-types))))

  (let* (type)
    (setq type src-code-type)
    (when (string= type "cpp")
      (setq type "C++"))
    (when (string= type "td")
      (setq type "tablegen")
      )
    (progn (newline-and-indent)
         (insert (format "#+BEGIN_SRC %s\n" type))
         (newline-and-indent)
         (insert "#+END_SRC\n")
         (previous-line 2)
         (org-edit-src-code))))
#+END_SRC

#+RESULTS:
: org-insert-src-block

*** Set keybinding

#+BEGIN_SRC emacs-lisp
(add-hook 'org-mode-hook '(lambda ()
                            ;; keybiding for insert source code
                            (local-set-key (kbd "C-c s") 'org-insert-src-block)))
#+END_SRC

*** enable execution of several languages

#+BEGIN_SRC emacs-lisp
(org-babel-do-load-languages 'org-babel-load-languages '((C . t)
                                                         (python . t)
                                                         (latex . t)
                                                         (dot . t)
                                                         ;;(jupyter . t)
                                                         ))
#+END_SRC

#+RESULTS:


#+BEGIN_SRC emacs-lisp
;;(setq ob-async-no-async-languages-alist '("python" "jupyter-python"))
#+END_SRC

#+RESULTS:
| python | jupyter-python |

** COMMENT Copy the section and open it as a html page
https://orgmode.org/worg/dev/org-element-api.html


#+BEGIN_SRC emacs-lisp
(defun chun/org-html-this ()
    (interactive)
    (let*
        ((cur-tree (org-element-at-point))
         (tmp-org-file (format "/tmp/%d.org" (random "")))
         )
      (message "%S" (org-element-interpret-data cur-tree))
      ))
#+END_SRC

#+RESULTS:
: chun/org-html-this








* Projectile related

Set project directories.

#+BEGIN_SRC emacs-lisp
(defcustom chun-mode/projectile-dirs '()
  "The yas-snippets directory."
  :type '(restricted-sexp :tag "Vector"
                          :match-alternatives
                          (lambda (xs) (and (vectorp xs) (seq-every-p #'stringp xs))))
  :group 'chun)
#+END_SRC

#+RESULTS:
: chun-mode/projectile-dirs

Set ignored directories.

#+BEGIN_SRC emacs-lisp
(defvar chun/projectile-ignored-directories
  '("^\\.git$" "env"
    "^\\.idea$" "^cmake-build-debug$"
    "^build*$" "^cmake-build-debug-*"
    "^__pycache__$")
  "Directories to ignore")
#+END_SRC

#+RESULTS:
: chun/projectile-globally-ignored-directories


Conduct the mainloop

#+BEGIN_SRC emacs-lisp
(require 'dash)

(after! projectile
  (-map (lambda (path)
          (projectile-add-known-project path)) chun-mode/projectile-dirs)

  (setq projectile-indexing-method 'native)
  (setq projectile-generic-command
        (mapconcat #'shell-quote-argument
                   (append (list "rg" "-0" "--files" "--follow" "--color=never" "--hidden")
                           (cl-loop for dir in chun/projectile-ignored-directories collect
                                    "--glob" collect (concat "!" dir))) " ") projectile-git-command
                                    projectile-generic-command))
#+END_SRC

#+RESULTS:
: rg -0 --files --follow --color\=never --hidden --glob \!\^\\.git\$ --glob \!env --glob \!\^\\.idea\$ --glob \!\^cmake-build-debug\$ --glob \!\^build\*\$ --glob \!\^cmake-build-debug-\* --glob \!\^__pycache__\$













* Python related

#+BEGIN_SRC emacs-lisp
(add-hook 'python-mode-hook (lambda ()
                             (remove-hook 'before-save-hook 'format-all-buffer--from-hook t)
                             ))

(defun chun/reset-python-hook ()
  (interactive)
  (remove-hook 'before-save-hook 'format-all-buffer--from-hook t)
  (remove-hook 'before-save-hook 'elpy-format-code t)
  )
#+END_SRC

#+RESULTS:
: chun/reset-python-hook





* anki related
** anki template

#+BEGIN_SRC emacs-lisp
(defvar chun/--anki-deck-candidates
  '()
  "Deck candidates for anki")


(setq chun/--anki-card-kinds
      '(
        "Basic (and reversed card)"
        "Basic (optional reversed card)"
        ))

(defun chun/anki-sentence-template (deck card)
  (interactive (list
                (helm :sources (helm-build-sync-source "anki-deck"
                                 :candidates chun/--anki-deck-candidates
                                 :fuzzy-match t)
                      :buffer "*anki deck*")
                (helm :sources (helm-build-sync-source "anki-card"
                                 :candidates chun/--anki-card-kinds
                                 :fuzzy-match t)
                      :buffer "*anki card*")))
  (let* ((input (read-string "Input:")))
    (insert (format "* %s :sentence:
:PROPERTIES:
:ANKI_NOTE_TYPE: %s
:ANKI_DECK: %s
:END:

,** Front
%s
,** Back
" input card deck input))))
#+END_SRC

#+RESULTS:
: chun/anki-sentence-template


* Third-party modes

** PTX mode

#+BEGIN_SRC emacs-lisp
(load-file (concat
            (--chun-cur-dir)
            "./ptx-mode.el"))
#+END_SRC

#+RESULTS:
: t


** ob-swift.el


#+BEGIN_SRC emacs-lisp
(load-file (concat (--chun-cur-dir) "./ob-swift.el"))
#+END_SRC

#+RESULTS:
: t
